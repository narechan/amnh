#!/usr/bin/perl -w

=head1 NAME

slideRule_forked.pl

=head1 SYNOPSIS

  slideRule_forked.pl

Options:

 --help        Show brief help and exit
 --alignfile   Is your input aln
 --outdir      Is your output dir
 --window      Is your window size
 --motion      Is the number of residues the 
                window moves per calculation (5' -> 3')
 --configfile  Is the configuration for your tests
 --procs       Is the number of procs for fork

The aln file must be in nexus format.

PAUP must be in your path or specified in config.
If specified in config, that location will be preferred.

The config must also specify all parameters for HOMPART
except the partition which is handled by this script. As in:

HOMPART=HOMPART nreps=10 search=heuristic seed=...

=head1 DESCRIPTION

Given an input matrix, do phylo tests for succssive windows
generated by moving 5'->3' along an alignment

=head1 AUTHOR

Apurva Narechania
anarechania *a|t* amnh.org

=head1 COPYRIGHT

Copyright (c) 2008 American Museum of Natural History

This library is free software;  
you can redistribute it and/or modify 
it under the same terms as Perl itself.

=cut

# ----------------------------------------------------

#####TODO: write a version that would work in parallel??
#####      write and OO module as the program gets more complex??

#####SETUP#####

use strict;
use Getopt::Long;
use Pod::Usage;
use Parallel::ForkManager;

my ($help, $alignfile, $outdir, $window, $motion, $configfile, $procs);
GetOptions(
    'h|help'          => \$help,
    'a|alignfile=s'   => \$alignfile,
    'o|outdir=s'      => \$outdir,
    'w|window=s'      => \$window,
    'm|motion=s'      => \$motion,
    'c|configfile=s'  => \$configfile,
    'p|procs=s'       => \$procs,
	   ) or pod2usage;

pod2usage if $help;

for my $option ($alignfile, $outdir, $window, $motion, $configfile, $procs){
    (warn ("Missing a required option\n") and pod2usage)
	unless ($option);
}

`mkdir -p $outdir/cmds`;
`mkdir -p $outdir/logs`;

#####MAIN#####

# parse your config
my $config = parse_config ($configfile);

# parse some basic stuff out of the nexus file
my ($charset, $ntax, $nchar, $datatype, $missing, $gap, $outgroup) = 
    parse_nexus ($alignfile);

# generate your charpartitions for various tests
my $partitions = generate_partitions ($window, $motion, $nchar);

# generate ILD tests for each of the partitions and run
my $pm = Parallel::ForkManager->new($procs);
foreach my $partition (sort {$a <=> $b} keys %$partitions){
    $pm->start and next;
    warn "ILD $partition\n";    

    my $start = $partitions->{$partition}[0];
    my $end   = $partitions->{$partition}[1];
    
    generate_ild ($start, 
		  $end, 
		  $config, 
		  "$outdir/cmds", 
		  "$outdir/logs", 
		  $nchar, 
		  $partition, 
		  $alignfile);
    
    `$config->{PAUP} -n $outdir/cmds/$partition.nex`;
    $pm->finish;
}
$pm->wait_all_children;


# parse the ILD output
opendir (ILD, "$outdir/logs");
my @logs = grep (/^.+\..+$/, readdir(ILD));
closedir (ILD);

my $ildmaster = {};
foreach my $log (@logs){
    my ($partition, $stuff) = split (/\./, $log);
    my $ilddata = parse_ild ("$outdir/logs/$log");
    ($ildmaster->{$partition} = $ilddata) if ($ilddata);
}


# tabulate
open (SUM, ">$outdir/summary");
foreach my $partition (sort {$a <=> $b} keys %$ildmaster){
    print SUM "$partition\t$ildmaster->{$partition}\n";
}
close (SUM);

#####SUBS#####

sub parse_ild{
    my $file    = shift;

    my $pval;
    open (ILD, "$file");
    while (my $line = <ILD>){
        chomp $line;

	if ($line =~m/\s*P\s{1}value\s*\=.*\=\s*(.+)/){
	    $pval = $1;
	}
    }
    close (ILD);
    
    return ($pval);
}

#        elsif ($line =~m/^Results\s*/){
#	    $indicator = 1;
#	}
#	elsif ($indicator == 1){
#	    push (@kept, $line);
#	}
#        elsif ($line =~m/==>end_record/){
#	    my @lengths;
#	    foreach my $keptline (@kept){
#		if ($keptline =~m/^\s{7}(\w+)\s+(\d+)/){
#		    my $length = $1;
#		    my $reps   = $2;


sub generate_ild{
    my $start      = shift;
    my $end        = shift;
    my $config     = shift;
    my $outdir_cmd = shift;
    my $outdir_log = shift;
    my $nchar      = shift;
    my $partition  = shift;
    my $alignfile  = shift;
    
    open (ILD, ">$outdir_cmd/$partition.nex");

    # print out the header                                                                        
    print ILD "#NEXUS\n";
    print ILD "SET increase = auto;\n";
    print ILD "EXECUTE $alignfile;\n";
    print ILD "LOG START file = $outdir_log/$partition.log replace = yes;\n";

    # create the partition set
    print ILD "BEGIN SETS;\n";
    print ILD "CHARSET C$partition = ";
    print ILD "$start-$end;\n";
    print ILD "END;\n";

    # create the experiment
    print ILD "BEGIN PAUP;\n";
	
    my $fivestart  = 1;
    my $fiveend    = $start - 1;

    my $threestart = $end + 1;
    my $threeend   = $nchar;

    print ILD "[!==>ILD: C$partition]\n";
    if ($fiveend == 0){
	print ILD "CHARPARTITION CharPart$partition = ";
	print ILD "1:C$partition, 2:$threestart-$threeend;\n";
    }
    elsif ($threestart > $nchar){
	print ILD "CHARPARTITION CharPart$partition = ";
	print ILD "1:C$partition, 2:$fivestart-$fiveend;\n";
    }
    else{ 
	print ILD "CHARPARTITION CharPart$partition = ";
	print ILD "1:C$partition, 2:$fivestart-$fiveend $threestart-$threeend;\n";
    }
	
    print ILD "$config->{HOMPART} ";
    print ILD "partition = CharPart$partition";
    
    if ($config->{SEARCH}){
	print ILD " / $config->{SEARCH};\n";
    }
    else{
	print ILD ";\n";
    }
    
    print ILD "[!==>end_record]\n";

    print ILD "END;\n";
    print ILD "LOG STOP;\n";
    print ILD "QUIT /warnTsave=no;\n";
}

sub generate_partitions{
    my $window = shift;
    my $motion = shift;
    my $nchar  = shift;
    
    my %parts;
    my $counter = 0;
    my $i = 1;
    while (1){
	$counter++;
	my $start = $i;
	my $end   = $i + ($window - 1);

	if ($end > $nchar){
	    $end = $nchar;
	    $parts{$counter} = [$start, $end];
	    last;
	}

	$parts{$counter} = [$start, $end];
	$i += $motion;
    }

    return (\%parts);
}

sub get_file_name{
    my $file = shift;
    my $name;

    if ($file =~m/.*\/(.*)$/){
        ($name) = $file =~m/.*\/(.*)$/;
    }
    else {
$name = $file;
    }

    return $name;
}

sub parse_nexus{
    my $alignfile = shift;
    open (NEX, "$alignfile");
    
    my $ntax;
    my $nchar;
    my $datatype;
    my $missing;
    my $gap;
    my %charset;
    my $outgroup;
    while (my $line = <NEX>){
	chomp $line;
	($nchar    = $1) if ($line =~m/nchar\s*=\s*(\d+)/i);
	($ntax     = $1) if ($line =~m/ntax\s*=\s*(\d+)/i);
	($datatype = $1) if ($line =~m/datatype\s*=\s*(\w+)/i);
	($missing  = $1) if ($line =~m/missing\s*=\s*(.{1})/i);
	($gap      = $1) if ($line =~m/gap\s*=\s*(.{1})/i);

	if ($line =~m/outgroup/i){
	    $line =~s/outgroup//ig;
	    $line =~s/\s+//g;
            $line =~s/\;//g;
	    
	    $outgroup = $line;
	}
	
	
	if ($line =~m/charset/i){
	    $line =~s/charset//ig;
	    $line =~s/\s+//g;
	    $line =~s/\;//g;
	    
	    my ($partition, $coords) = 
		split (/\=/, $line);
	    $charset{$partition} = $coords;
	}
    }
    close (NEX);
    return (\%charset, $ntax, $nchar, $datatype, $missing, $gap, $outgroup);
}

sub parse_config{
    my $file = shift;

    my %config;
    open (F, "$file");
    while (my $line = <F>){
        chomp $line;
        my ($key, $value) = split (/\=/, $line, 2);
        $config{$key} = $value;

    }

    # check for PAUP in user's path if not in config                                     
    if (! exists($config{"PAUP"})){
        my $paup = `which paup`;
        chomp $paup;

        if (defined ($paup)){
            $config{"PAUP"} = $paup;
        }
        else {
            die "no PAUP specified!\n";
	}
    }

    return (\%config);
    close (F);
}
