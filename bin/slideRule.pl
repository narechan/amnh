#!/usr/bin/perl -w

=head1 NAME

slideRule.pl

=head1 SYNOPSIS

  slideRule.pl

Options:

 --help        Show brief help and exit
 --alignfile   Is your input aln
 --outdir      Is your output dir
 --window      Is your window size
 --motion      Is the number of residues the 
                window moves per calculation (5' -> 3')
 --configfile  Is the configuration for your tests

The aln file must be in nexus format.

PAUP must be in your path or specified in config.
If specified in config, that location will be preferred.

The config must also specify all parameters for HOMPART
except the partition which is handled by this script. As in:

HOMPART=HOMPART nreps=10 search=heuristic seed=...

=head1 DESCRIPTION

Given an input matrix, do phylo tests for succssive windows
generated by moving 5'->3' along an alignment

=head1 AUTHOR

Apurva Narechania
anarechania *a|t* amnh.org

=head1 COPYRIGHT

Copyright (c) 2008 American Museum of Natural History

This library is free software;  
you can redistribute it and/or modify 
it under the same terms as Perl itself.

=cut

# ----------------------------------------------------

#####TODO: write a version that would work in parallel??
#####     

#####SETUP#####

use strict;
use Getopt::Long;
use Pod::Usage;

my ($help, $alignfile, $outdir, $window, $motion, $configfile);
GetOptions(
    'h|help'          => \$help,
    'a|alignfile=s'   => \$alignfile,
    'o|outdir=s'      => \$outdir,
    'w|window=s'      => \$window,
    'm|motion=s'      => \$motion,
    'c|configfile=s'  => \$configfile,
    ) or pod2usage;

pod2usage if $help;

for my $option ($alignfile, $outdir, $window, $motion, $configfile){
    (warn ("Missing a required option\n") and pod2usage)
	unless ($option);
}

my $alignname = get_file_name ($alignfile);

`mkdir -p $outdir`;

#####MAIN#####

# parse your config
my $config = parse_config ($configfile);

# parse some basic stuff out of the nexus file
warn "Getting some data from your nexus file.\n";
my ($charset, $ntax, $nchar, $datatype, $missing, $gap, $outgroup) = 
    parse_nexus ($alignfile);

# generate your charpartitions for various tests
warn "Generating char parts\n";
my $partitions = generate_partitions ($window, $motion, $nchar);

# generate ILD tests for each of the partitions
generate_ild_command ($partitions, $config, $alignname, $nchar);

# run the ILD tests
`$config->{PAUP} -n $outdir/$alignname.ild.cmds`;

# parse the ILD output
my $ild = parse_ild_output ($alignname, $outdir);

# tabulate
open (SUM, ">$outdir/$alignname.ild.summary");
foreach my $partition (sort keys %$ild){
    print SUM "$partition\t$ild->{$partition}\n";
}
close (SUM);

#####SUBS#####

sub parse_ild_output{
    my $alignname = shift;
    my $outdir    = shift;

    my $partition;
    my $pval;

    my %ilddata;
    open (ILD, "$outdir/$alignname.ild.log");
    while (my $line = <ILD>){
        chomp $line;

        if ($line =~m/==>ILD:\s*(\w+)/i){
            $partition = $1;
        }
	elsif ($line =~m/\s*P\s{1}value\s*\=.*\=\s*(.+)/){
	    $pval = $1;
	}
	elsif ($line =~m/==>end_record/){
	    $ilddata{$partition} = $pval;
	}
    }
    close (ILD);
    
    return (\%ilddata);
}

#        elsif ($line =~m/^Results\s*/){
#	    $indicator = 1;
#	}
#	elsif ($indicator == 1){
#	    push (@kept, $line);
#	}
#        elsif ($line =~m/==>end_record/){
#	    my @lengths;
#	    foreach my $keptline (@kept){
#		if ($keptline =~m/^\s{7}(\w+)\s+(\d+)/){
#		    my $length = $1;
#		    my $reps   = $2;


sub generate_ild_command{
    my $partitions = shift;
    my $config     = shift;
    my $alignname  = shift;
    my $nchar      = shift;
    
    open (ILD, ">$outdir/$alignname.ild.cmds");

    # print out the header                                                                        
    print ILD "#NEXUS\n";
    print ILD "SET increase = auto;\n";
    print ILD "EXECUTE $alignfile;\n";
    print ILD "LOG START file = $outdir/$alignname.ild.log replace = yes;\n";

    # create the partition sets
    print ILD "BEGIN SETS;\n";
    foreach my $partition (sort {$a <=> $b} keys %$partitions){
	my $start = $partitions->{$partition}[0];
	my $end   = $partitions->{$partition}[1];
	print ILD "CHARSET C$partition = ";
	print ILD "$start-$end;\n";
    }
    print ILD "END;\n";

    # create the experiments
    print ILD "BEGIN PAUP;\n";
    foreach my $partition (sort {$a <=> $b} keys %$partitions){
	my $start = $partitions->{$partition}[0];
	my $end   = $partitions->{$partition}[1];
	
	my $fivestart  = 1;
	my $fiveend    = $start - 1;

	my $threestart = $end + 1;
	my $threeend   = $nchar;

	print ILD "[!==>ILD: C$partition]\n";
	if ($fiveend == 0){
	    print ILD "CHARPARTITION CharPart$partition = ";
	    print ILD "1:C$partition, 2:$threestart-$threeend;\n";
	}
	elsif ($threestart > $nchar){
	    print ILD "CHARPARTITION CharPart$partition = ";
            print ILD "1:C$partition, 2:$fivestart-$fiveend;\n";
	}
	else{ 
	    print ILD "CHARPARTITION CharPart$partition = ";
            print ILD "1:C$partition, 2:$fivestart-$fiveend $threestart-$threeend;\n";
	}
	
	print ILD "$config->{HOMPART} ";
	print ILD "partition = CharPart$partition;\n";
	print ILD "[!==>end_record]\n";
    }
    print ILD "END;\n";
    print ILD "LOG STOP;\n";
    print ILD "QUIT /warnTsave=no;\n";
}

sub generate_partitions{
    my $window = shift;
    my $motion = shift;
    my $nchar  = shift;
    
    my %parts;
    my $counter = 0;
    my $i = 1;
    while (1){
	$counter++;
	my $start = $i;
	my $end   = $i + ($window - 1);

	if ($end > $nchar){
	    $end = $nchar;
	    $parts{$counter} = [$start, $end];
	    last;
	}

	$parts{$counter} = [$start, $end];
	$i += $motion;
    }

    return (\%parts);
}

sub get_file_name{
    my $file = shift;
    my $name;

    if ($file =~m/.*\/(.*)$/){
        ($name) = $file =~m/.*\/(.*)$/;
    }
    else {
	$name = $file;
    }

    return $name;
}

sub parse_nexus{
    my $alignfile = shift;
    open (NEX, "$alignfile");
    
    my $ntax;
    my $nchar;
    my $datatype;
    my $missing;
    my $gap;
    my %charset;
    my $outgroup;
    while (my $line = <NEX>){
	chomp $line;
	($nchar    = $1) if ($line =~m/nchar\s*=\s*(\d+)/i);
	($ntax     = $1) if ($line =~m/ntax\s*=\s*(\d+)/i);
	($datatype = $1) if ($line =~m/datatype\s*=\s*(\w+)/i);
	($missing  = $1) if ($line =~m/missing\s*=\s*(.{1})/i);
	($gap      = $1) if ($line =~m/gap\s*=\s*(.{1})/i);

	if ($line =~m/outgroup/i){
	    $line =~s/outgroup//ig;
	    $line =~s/\s+//g;
            $line =~s/\;//g;
	    
	    $outgroup = $line;
	}
	
	
	if ($line =~m/charset/i){
	    $line =~s/charset//ig;
	    $line =~s/\s+//g;
	    $line =~s/\;//g;
	    
	    my ($partition, $coords) = 
		split (/\=/, $line);
	    $charset{$partition} = $coords;
	}
    }
    close (NEX);
    return (\%charset, $ntax, $nchar, $datatype, $missing, $gap, $outgroup);
}

sub parse_config{
    my $file = shift;

    my %config;
    open (F, "$file");
    while (my $line = <F>){
        chomp $line;
        my ($key, $value) = split (/\=/, $line, 2);
        $config{$key} = $value;

    }

    # check for PAUP in user's path if not in config                                     
    if (! exists($config{"PAUP"})){
        my $paup = `which paup`;
        chomp $paup;

        if (defined ($paup)){
            $config{"PAUP"} = $paup;
        }
        else {
            die "no PAUP specified!\n";
	}
    }

    return (\%config);
    close (F);
}
